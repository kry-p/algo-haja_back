// 패스워드 검증 정규식
export const passwordRegex = RegExp(
  /^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&;()+\-_=/~`[\]{}'".,])[A-Za-z\d@$!%*#?&;()+\-_=/~`[\]{}'".,]{8,}$/,
);

// 언어별 소스코드 확장자
export const EXT_LANG = new Map([
  ['c', 'C / C++'],
  ['cpp', 'C++'],
  ['cxx', 'C++'],
  ['cc', 'C++'],
  ['py', 'Python'],
  ['php', 'PHP'],
  ['java', 'Java'],
  ['js', 'JavaScript'],
  ['ts', 'TypeScript'],
  ['sh', 'Shell'],
  ['vb', 'Visual Basic'],
  ['vbs', 'Visual Basic'],
  ['cs', 'C#'],
  ['r', 'R'],
  ['luac', 'lua'],
  ['perl', 'perl'],
  ['go', 'Go'],
  ['rs', 'Rust'],
  ['kt', 'Kotlin'],
  ['m', 'Objective-C'],
  ['mm', 'Objective-C++'],
  ['swift', 'Swift'],
  ['rb', 'Ruby'],
]);

// Enums
// Git 저장소 모드
export const GIT_RULE_1 = 1;
export const GIT_RULE_2 = 2;

// BOJ 태그
export const BOJ_TAGS = {
  '0_1_bfs': '0-1 너비 우선 탐색',
  '2_sat': '2-sat',
  a_star: 'a*',
  ad_hoc: '애드 혹',
  aho_corasick: '아호-코라식',
  alien: 'Aliens 트릭',
  arbitary_precision: '임의 정밀도 / 큰 수 연산',
  arithmetic: '사칙연산',
  articulation: '단절점과 단절선',
  backtracking: '백트래킹',
  bayes: '베이즈 정리',
  bellman_ford: '벨만-포드',
  berlekamp_massey: '벌래캠프-매시',
  bfs: '너비 우선 탐색',
  biconnected_component: '이중 연결 요소',
  bidirectional_search: '양방향 탐색',
  binary_search: '이분 탐색',
  bipartite_graph: '이분 그래프',
  bipartite_matching: '이분 매칭',
  bitmask: '비트마스킹',
  bitset: '비트 집합',
  bruteforcing: '브루트포스 알고리즘',
  burnside: '번사이드 보조정리',
  cactus: '선인장',
  calculus: '미적분학',
  case_work: '많은 조건 분기',
  centroid: '센트로이드',
  centroid_decomposition: '센트로이드 분할',
  chordal_graph: '현 그래프',
  cht: '볼록 껍질을 이용한 최적화',
  circulation: '서큘레이션',
  combinatorics: '조합론',
  constructive: '구성적',
  convex_hull: '볼록 껍질',
  coordinate_compression: '값 / 좌표 압축',
  crt: '중국인의 나머지 정리',
  dancing_links: '춤추는 링크',
  data_structures: '자료 구조',
  degree_sequence: '차수열',
  delaunay: '델로네 삼각분할',
  deque: '덱',
  differential_cryptanalysis: '차분 공격',
  dijkstra: '다익스트라',
  directed_mst: '유향 최소 신장 트리',
  discrete_kth_root: '이산 k제곱근',
  discrete_log: '이산 로그',
  discrete_sqrt: '이산 제곱근',
  disjoint_set: '분리 집합',
  divide_and_conquer: '분할 정복',
  divide_and_conquer_optimization: '분할 정복을 사용한 최적화',
  dominator_tree: '도미네이터 트리',
  dp: '다이나믹 프로그래밍',
  dp_bitfield: '비트필드를 이용한 다이나믹 프로그래밍',
  dp_connection_profile: '커넥션 프로파일을 이용한 다이나믹 프로그래밍',
  dp_deque: '덱을 이용한 다이나믹 프로그래밍',
  dp_tree: '트리에서의 다이나믹 프로그래밍',
  dual_graph: '쌍대 그래프',
  duality: '쌍대성',
  euclidean: '유클리드 호제법',
  euler_characteristic: '오일러 지표 (χ=V-E+F)',
  euler_phi: '오일러 피 함수',
  euler_tour_technique: '오일러 경로 테크닉',
  eulerian_path: '오일러 경로',
  exponentiation_by_squaring: '분할 정복을 이용한 거듭제곱',
  extended_euclidean: '확장 유클리드 호제법',
  fft: '고속 푸리에 변환',
  flow: '최대 유량',
  floyd_warshall: '플로이드-와샬',
  flt: '페르마의 소정리',
  game_theory: '게임 이론',
  gaussian_elimination: '가우스 소거법',
  general_matching: '일반적인 매칭',
  generating_function: '생성 함수',
  geometry: '기하학',
  geometry_3d: '3차원 기하학',
  geometry_hyper: '4차원 이상의 기하학',
  graph_traversal: '그래프 탐색',
  graphs: '그래프 이론',
  greedy: '그리디 알고리즘',
  green: '그린 정리',
  half_plane_intersection: '반평면 교집합',
  hall: '홀의 결혼 정리',
  hash_set: '해시를 사용한 집합과 맵',
  hashing: '해싱',
  heuristics: '휴리스틱',
  hirschberg: '히르쉬버그',
  hld: 'Heavy-light 분할',
  hungarian: '헝가리안',
  implementation: '구현',
  inclusion_and_exclusion: '포함 배제의 원리',
  interpreter: '인터프리터',
  kitamasa: '키타마사',
  kmp: 'KMP',
  knapsack: '배낭 문제',
  knuth: '크누스 최적화',
  knuth_x: '크누스 X',
  lazyprop: '느리게 갱신되는 세그먼트 트리',
  lca: '최소 공통 조상',
  line_intersection: '선분 교차 판정',
  linear_algebra: '선형대수학',
  linear_programming: '선형 계획법',
  linearity_of_expectation: '기댓값의 선형성',
  link_cut_tree: '링크/컷 트리',
  linked_list: '연결 리스트',
  lis: '가장 긴 증가하는 부분 수열: O(n log n)',
  lucas: '뤼카 정리',
  majority_vote: '보이어-무어 다수결 투표',
  manacher: '매내처',
  math: '수학',
  matroid: '매트로이드',
  mcmf: '최소 비용 최대 유량',
  merge_sort_tree: '머지 소트 트리',
  mfmc: '최대 유량 최소 컷 정리',
  miller_rabin: '밀러-라빈 소수 판별법',
  min_enclosing_circle: '최소 외접원',
  mitm: '중간에서 만나기',
  mo: "mo's",
  mobius_inversion: '뫼비우스 반전 공식',
  modular_multiplicative_inverse: '모듈로 곱셈 역원',
  monotone_queue_optimization: '단조 큐를 이용한 최적화',
  mst: '최소 스패닝 트리',
  multi_segtree: '다차원 세그먼트 트리',
  multipoint_evaluation: '다중 대입값 계산',
  number_theory: '정수론',
  numerical_analysis: '수치해석',
  offline_dynamic_connectivity: '오프라인 동적 연결성 판정',
  offline_queries: '오프라인 쿼리',
  palindrome_tree: '회문 트리',
  parametric_search: '매개 변수 탐색',
  parsing: '파싱',
  pbs: '병렬 이분 탐색',
  permutation_cycle_decomposition: '순열 사이클 분할',
  physics: '물리학',
  pick: '픽의 정리',
  pigeonhole_principle: '비둘기집 원리',
  planar_graph: '평면 그래프',
  point_in_convex_polygon: '볼록 다각형 내부의 점 판정',
  point_in_non_convex_polygon: '오목 다각형 내부의 점 판정',
  pollard_rho: '폴라드 로',
  polygon_area: '다각형의 넓이',
  precomputation: '런타임 전의 전처리',
  prefix_sum: '누적 합',
  primality_test: '소수 판정',
  priority_queue: '우선순위 큐',
  probability: '확률론',
  pst: '퍼시스턴트 세그먼트 트리',
  pythagoras: '피타고라스 정리',
  queue: '큐',
  rabin_karp: '라빈-카프',
  randomization: '무작위화',
  rb_tree: '레드-블랙 트리',
  recursion: '재귀',
  regex: '정규 표현식',
  rope: '로프',
  rotating_calipers: '회전하는 캘리퍼스',
  scc: '강한 연결 요소',
  segtree: '세그먼트 트리',
  sieve: '에라토스테네스의 체',
  simulated_annealing: '담금질 기법',
  simulation: '시뮬레이션',
  sliding_window: '슬라이딩 윈도우',
  slope_trick: '함수 개형을 이용한 최적화',
  smaller_to_larger: '작은 집합에서 큰 집합으로 합치는 테크닉',
  sorting: '정렬',
  sparse_table: '희소 배열',
  splay_tree: '스플레이 트리',
  sprague_grundy: '스프라그-그런디 정리',
  sqrt_decomposition: '제곱근 분할법',
  stable_marriage: '안정 결혼 문제',
  stack: '스택',
  statistics: '통계학',
  stoer_wagner: '스토어-바그너',
  string: '문자열',
  suffix_array: '접미사 배열과 LCP 배열',
  suffix_tree: '접미사 트리',
  sweeping: '스위핑',
  ternary_search: '삼분 탐색',
  top_tree: '탑 트리',
  topological_sorting: '위상 정렬',
  tree_compression: '트리 압축',
  tree_isomorphism: '트리 동형 사상',
  tree_set: '트리를 사용한 집합과 맵',
  trees: '트리',
  trie: '트라이',
  tsp: '외판원 순회 문제',
  two_pointer: '두 포인터',
  utf8: 'utf-8 입력 처리',
  voronoi: '보로노이 다이어그램',
  z: 'Z',
};
